# /usr/bin/python
# -*-python-*-

"""Repair the SVG files generated by sketch."""

import sys, os, os.path, re

standalone = 'yes'                      # not sure what effect this should have
ns = 'http://www.w3.org/2000/svg'
ns2 = 'http://www.w3.org/1999/xlink'
public = '-//W3C//DTD SVG 20010904//EN'
system = 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'

isXmlDeclWanted = 0
isDoctypeWanted = 0
isCssMungingWanted = 1

class AttParser:
    """Parse th attributes of an object."""
    def __init__(self, text=''):
        self._next = self._startState # this represents the state of the FSM
        if text:
            self.parse(text)

    def parse(self, text):
        """Scan in the text."""
        for c in text:
            self._next = self._next(c)

    def has_key(self, key):
        return self.__dict__.has_key(key)

    def _startState(self, c):
        if c <= ' ':
            return self._startState
        self._key = c
        return self._keyState

    def _keyState(self, c):
        """Expecting rest of key."""
        if c == '=':
            return self._eqState
        elif c <= ' ':
            return self._spEqState
        self._key += c
        return self._keyState

    def _spEqState(self, c):
        """Expecting space followed by ="""
        if c == '=':
            return self._eqState
        # It must be a space then...
        return self._spEqState

    def _eqState(self, c):
        """Expecting space followed by ' or quote."""
        if c == '"' or c == "'":
            self._quote = c
            self._value = ''
            return self._quotState
        elif c == "'":
            self._value = ''
            return self._aposState
        # It must be a space, then.
        return self._eqState

    def _quotState(self, c):
        """Expeting characters followed by quote."""
        if c == self._quote:
            self.__dict__[self._key] = self._value
            del self._key
            del self._value
            del self._quote
            return self._startState
        self._value += c
        return self._quotState

class CssParser:
    """Ditto for CSS data. Very simplistic, does not decompose values."""
    def __init__(self, text=''):
        self._next = self._startState
        if text:
            self.parse(text)

    def parse(self, text):
        for c in text:
            self._next = self._next(c)

    def has_key(self, key):
        return self.__dict__.has_key(key)

    def items(self):
        return self.__dict__.items()

    def _startState(self, c):
        if c <= ' ' or c == ';':
            return self._startState
        self._key = c
        return self._keyState

    def _keyState(self, c):
        if c == ':':
            self._value = ''
            return self._valueState
        elif c <= ' ':
            return self._spValueState
        self._key += c
        return self._keyState

    def _spValueState(self, c):
        if c == ':':
            self._value = ''
            return self._valueState
        # It must be space!
        return self._spValueState

    def _valueState(self, c):
        if c == ';':
            self.__dict__[self._key] = self._value
            del self._key
            del self._value
            return self._startState
        self._value += c
        return self._valueState

def explodeCss(m):
    """Given a regular expression match object, convert style to atts"""
    css = CssParser(m.group(1))
    css.parse(';')
    res = ''
    for key, val in css.items():
        if type(val) == type('') and key[0] != '_':
            res += key + '="' + val + '" '
    return res[:-1]                     # strip trailing space
        

def processFile(fileName):
    print 'Reading', fileName
    input = open(fileName, 'r')
    text = input.read()
    input.close()

    bakName = fileName + '~'
    bak = open(bakName, 'w')
    bak.write(text)
    bak.close()
    print 'Wrote backup file to', bakName

    beg = text.index('<svg ') + 5
    end = text.index('>', beg + 3)
    atts = AttParser(text[beg:end])
    if not atts.has_key('viewBox'):
        print 'Add viewbox.'
        text = text[:beg] + 'viewBox="0 0 ' \
                             + atts.width + ' ' + atts.height \
                             + '"\n\t' + text[beg:] 
    if not atts.has_key('xmlns:xlink'):
        text = text[:beg] + 'xmlns:xlink="' + ns2 + '"\n\t' + text[beg:]
    if not atts.has_key('xmlns'):
        text = text[:beg] + 'xmlns="' + ns + '"\n\t' + text[beg:]

    if isCssMungingWanted:
        text = re.sub('style="([^"]*)"', explodeCss, text)

    beg = 0
	
    pos = text.find('<!DOCTYPE')
    if pos > 0:
        pos = text.index('>', pos + 9) + 1
    elif text[:6] == '<?xml ':
        pos = text.index('?>') + 2
    else:
        pos = 0

    tx = ''
    if isXmlDeclWanted:
        tx += '<?xml version="1.0" standalone="' + standalone + '"?>\n'
    if isDoctypeWanted:
        tx +=  '<!DOCTYPE svg PUBLIC "' + public + '"\n' + \
             '    "' + system + '">\n'

    text = tx + text[pos:].strip()
    
    output = open(fileName, 'w')
    output.write(text)
    output.close()
    print 'Wrote fixed SVG to', fileName


if __name__ == '__main__':
    for arg in sys.argv[1:]:
        if arg[0] == '-':
            if arg == '-explodeCss':
                isCssMungingWanted = 1
            elif arg == '-doctype':
                isDoctypeWanted = 1
            elif arg == '-xml':
                isXmlDeclWanted = 1
            else:
                print 'Unknown option (%s)' % arg
                sys.exit(1)
        else:
            processFile(arg)
